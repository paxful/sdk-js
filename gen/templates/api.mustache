import * as url from "url";
import { CredentialStorage } from "../../oauth";
import { ApiConfiguration } from "../../ApiConfiguration";
import { executeRequestAuthorized } from "../../commands";
import { RequestBuilder } from "../../commands/Invoke";
import { Blob, Response } from "node-fetch";

type ModelObject = any;

/**
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected readonly apiConfiguration: ApiConfiguration
    protected readonly credentialStorage: CredentialStorage

    constructor(configuration: ApiConfiguration, credentialStorage: CredentialStorage) {
        this.apiConfiguration = configuration;
        this.credentialStorage = credentialStorage;
    }
}

/**
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

{{#models}}
{{#model}}{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{#isObject}}{{>modelGeneric}}{{/isObject}}{{^isObject}}{{>modelAlias}}{{/isObject}}{{/isEnum}}{{/model}}
{{/models}}
{{#apiInfo}}{{#apis}}{{#operations}}
/**
 * {{classname}} - fetch parameter creator{{#description}}
 * {{&description}}{{/description}}
 * @export
 */
export const {{classname}}FetchParamCreator = {
{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    {{nickname}}({{#allParams}}{{paramName}}?: {{{dataType}}}, {{/allParams}}options: any = {}): FetchArgs {
        const localVarPath = `${process.env.PAXFUL_DATA_HOST}/paxful/v1{{{path}}}`{{#pathParams}}
            .replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};
        const localVarUrlObj = url.parse(localVarPath, true);
        const localVarRequestOptions = Object.assign({ method: '{{httpMethod}}' }, options);
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
{{#hasFormParams}}
        const localVarFormParams = new url.URLSearchParams();
{{/hasFormParams}}
{{#queryParams}}
        {{#isListContainer}}
        if ({{paramName}}) {
        {{#isCollectionFormatMulti}}
            localVarQueryParameter['{{baseName}}'] = {{paramName}};
        {{/isCollectionFormatMulti}}
        {{^isCollectionFormatMulti}}
            localVarQueryParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]);
        {{/isCollectionFormatMulti}}
        }
        {{/isListContainer}}
        {{^isListContainer}}
        if ({{paramName}} !== undefined) {
            {{#isDateTime}}
            localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any).toISOString();
            {{/isDateTime}}
            {{^isDateTime}}
            {{#isDate}}
            localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any).toISOString();
            {{/isDate}}
            {{^isDate}}
            localVarQueryParameter['{{baseName}}'] = {{paramName}};
            {{/isDate}}
            {{/isDateTime}}
        }
        {{/isListContainer}}

{{/queryParams}}
{{#headerParams}}
        {{#isListContainer}}
        if ({{paramName}}) {
            localVarHeaderParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
        }
        {{/isListContainer}}
        {{^isListContainer}}
        if ({{paramName}} !== undefined && {{paramName}} !== null) {
            localVarHeaderParameter['{{baseName}}'] = String({{paramName}});
        }
        {{/isListContainer}}

{{/headerParams}}
{{#formParams}}
        {{#isListContainer}}
        if ({{paramName}}) {
        {{#isCollectionFormatMulti}}
            {{paramName}}.forEach((element) => {
                localVarFormParams.append('{{baseName}}', element as any);
            })
        {{/isCollectionFormatMulti}}
        {{^isCollectionFormatMulti}}
                localVarFormParams.set('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
        {{/isCollectionFormatMulti}}
        }
        {{/isListContainer}}
        {{^isListContainer}}
        if ({{paramName}} !== undefined) {
            localVarFormParams.set('{{baseName}}', {{paramName}} as any);
        }
        {{/isListContainer}}

{{/formParams}}
{{#hasFormParams}}
        localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

{{/hasFormParams}}
{{#bodyParam}}
        {{^consumes}}
        localVarHeaderParameter['Content-Type'] = 'application/json';
        {{/consumes}}
        {{#consumes.0}}
        localVarHeaderParameter['Content-Type'] = '{{{mediaType}}}';
        {{/consumes.0}}

{{/bodyParam}}
        localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        delete localVarUrlObj?.search;
        localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
{{#hasFormParams}}
        localVarRequestOptions.body = localVarFormParams.toString();
{{/hasFormParams}}
{{#bodyParam}}
        const needsSerialization = (<any>"{{dataType}}" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
        localVarRequestOptions.body =  needsSerialization ? JSON.stringify({{paramName}} || {}) : ({{paramName}} || "");
{{/bodyParam}}

        return {
            url: url.format(localVarUrlObj),
            options: localVarRequestOptions,
        };
    },
{{/operation}}
};

{{#operation}}
export type {{classname}}{{operationIdCamelCase}}Params = {
    {{#allParams}}
    /**
     * {{description}}
     */
    {{paramName}}?: {{{dataType}}};

    {{/allParams}}
}

{{/operation}}

/**
 * {{classname}}{{#description}}
 * {{{description}}}{{/description}}
 *
 * @export
 * @class {{classname}}
 * @extends {BaseAPI}
 */
export class {{classname}} extends BaseAPI {
    {{#operation}}
    /**
     * {{&notes}}
     *
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     * @param { {{classname}}{{operationIdCamelCase}}Params } params
     * @param {*} [options] Override http request option.
     * @memberof {{classname}}
     */
    public {{nickname}}({{#allParams.0}}params{{^requiredParams.0}}?{{/requiredParams.0}}: {{classname}}{{operationIdCamelCase}}Params, {{/allParams.0}}options?: any): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Response{{/returnType}}> {
        const localVarFetchArgs = {{classname}}FetchParamCreator.{{nickname}}({{#allParams}}params?.{{paramName}}, {{/allParams}}options);
        const requestBuilder = new RequestBuilder(localVarFetchArgs.url, localVarFetchArgs.options);
        requestBuilder.acceptJson();

        return executeRequestAuthorized(requestBuilder, this.apiConfiguration, this.credentialStorage);
    }

    {{/operation}}
}
{{/operations}}{{/apis}}{{/apiInfo}}

export interface FluentApi {
    {{#apiInfo}}{{#apis}}
    {{classVarName}}: {{classname}};
    {{/apis}}{{/apiInfo}}
}

export default (configuration: ApiConfiguration, credentialStorage: CredentialStorage): FluentApi => ({
    {{#apiInfo}}{{#apis}}
    {{classVarName}}: new {{classname}}(configuration, credentialStorage),
    {{/apis}}{{/apiInfo}}
})